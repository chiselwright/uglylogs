# vi:ts=4:sw=4:
package UglyMUG::Player::Email;
use strict;
use warnings;

use Data::Dumper;
use Email::Valid;

# make sure we have a version
use vars qw{ $VERSION };
$VERSION = do{my@r=q$Revision: 1.1.1.1 $=~/\d+/g;sprintf '%d.'.'%02d'x$#r,@r};

=head1 NAME

UglyMUG::Player::Email - get player emails

=head1 VERSION

  $Id: Email.pm,v 1.1.1.1 2002/02/20 12:30:47 chiselwright Exp $

=head2 DESCRIPTION

This module reads a specified email.list as generated by
UglyMUG, and can be used to return information from that file

Currently the module only B<reads> information, and can't
be used to change anything. I'm not sure we should be able
to change anything anyway.

=cut

=head2 new()

Create a new instance of this object

=cut
sub new {
	my $this	= shift;
	my %params	= @_;
	my $class	= ref($this) || $this;
	my $self	= {};

	bless $self, $class;
	$self->initialise(\%params);

	# if we're caching, then read the email list
	# and store the information
	if ($self->{'_conf'}{'cache'}) {
		$self->cache_player_info();
	}
	return $self;
}

=head2 initialise($self, [$options])

Initalise a new instance of the object

=cut
sub initialise() {
	my $self = shift;
	my $href = shift;

	# do we have a list?
	if (exists $href->{'list'}) {
		## does the file exist? is it really a file?
		if (-f $href->{'list'}) {
			$self->{'_conf'}{'filename'} = $href->{'list'};
		}
		else {
			die "no such file: $href->{'list'}";
		}
	}
	else {
		warn qq[you need to specify a value for 'list' in new()];
		exit;
	}

	# set some default options
	$self->{'_conf'}{'cache'} = $href->{'cache'} || 1;
}

=head2 cache_player_info($self)

foo

=cut
sub cache_player_info($) {
	my $self = shift;
	my %count;				# for debugging / reporting

	# open the email list
	open (LIST, "<$self->{'_conf'}{'filename'}")
		or die "can't open $self->{'_conf'}{'filename'}: $!";

	# loop through the entries in the file
	# the file is in the following format:
	#   <playername>|<playerid>|<email|NO_MAIL_ADDRESS>
	while (<LIST>) {
		my ($name, @alias, $id, $email, $nohuh);
		chomp;					# get rid of the newline

		# split the line at |
		($name, @alias[0 .. 4], $id, $email, $nohuh) = split(/\|/);

		# store the info in $self; keyed by ID
		$self->{'player_data'}{$id} = {
			'name'		=> $name,
			'email'		=> ($email eq 'NO_MAIL_ADDRESS') ? undef : $email,
			'aliases'	=> \@alias,
			'no_huh'	=> $nohuh,
		};

		# count players with/without emails
		if ($email eq 'NO_MAIL_ADDRESS') {
			$count{'unset'} ++;
		}
		else {
			$count{'set'} ++;
		}
	}

	# print report / debugging
	printf "Set:   %04d\nUnset: %04d\nTotal: %04d\n",
			$count{'set'},
			$count{'unset'},
			$count{'set'} + $count{'unset'}
				if $self->{'_conf'}{'DEBUG'};
}

=head2 get_player_info($self, $id)

This function will return player information
for a given playerid.

Returns a hash-reference with the information.

=cut
sub get_player_info($$) {
	my ($self, $id) = @_;

	# if we've pre-cached we can just return
	# a portion of $self (if it exists)
	if ($self->{'_conf'}{'cache'}) {
		if (exists $self->{'player_data'}{$id}) {
			return $self->{'player_data'}{$id};
		}
		else {
			# no information for anyone with that ID
			return undef;
		}	
	}
	else {
		# we need to search the file - slow, but hey
		# ** we'll do this later **
		# return undef for now
		return undef;
	}
}

=head2 get_player_email($self, $id)

This is a wrapper around get_player_info(),
	and simply makes a call to that, returning
	the e'mail address from the hash - assuming
	it's not undef.

	B<We need to think of a way to distinguish between PlayerNotFound and EmailNotSet>.

=cut
sub get_player_email($$) {
	my ($self, $id) = @_;
	my ($result);

	# make a call to get_player_info()
	$result = $self->get_player_info($id);

	if (not defined $result) {
		# playerid not found
		return undef;
	}
	elsif (not defined $result->{'email'}) {
		# player found, but no address set
		return 0E0;
	}
	elsif (not Email::Valid->address(
		'-address'		=> $result->{'email'},
		'-mxcheck'		=> 0,
	)) {
		# not a valid email address
		warn "$result->{'email'} does not conform to RFC822\n"
				if $self->{'_conf'}{'DEBUG'};
		return undef;
	}
	else {
		# player found, and has an email address
		return $result->{'email'};
	}
}

=head2 get_player_name($self, $id)

	This is a wrapper around get_player_info(),
	and simply makes a call to that, returning
	the name from the hash - assuming
	it's not undef.

	B<We need to think of a way to distinguish between PlayerNotFound and EmailNotSet>.

=cut
sub get_player_name($$) {
	my ($self, $id) = @_;
	my ($result);

	# make a call to get_player_info()
	$result = $self->get_player_info($id);

	if (not defined $result) {
		# playerid not found
		return undef;
	}
	elsif (not defined $result->{'name'}) {
		# player found, but no name (!!)
		return 0E0;
	}
	else {
		# player found, and has a name
		return $result->{'name'};
	}
}

=head2 get_formatted_email_address($self, $id)

This function uses get_player_name() and get_player_email()
to construct and return a string of the form "B<Player Name E<lt>email@foo.comE<gt>>"
for a given player id

=cut
sub get_formatted_email_address($$) {
	my ($self, $id) = @_;
	my ($name, $email);

	$name  = $self->get_player_name($id);
	$email = $self->get_player_email($id);

	# return if email or name are not defined
	if ((not defined $name) or (not defined $email)) {
		return undef;
	}

	# if $email == 0E0 then no address is set
	if (not $email) {
		return undef;
	}

	# if $name == 0E0 then no name set; we can live with this
	if (not $name) {
		$name = 'No Name';
	}

	# otherwise return "$name <$email>"
	return "$name <$email>";
}

=head2 requires_huh($self, $id)

This function returns true (1) if the player with id $id
want huh logs, or false (0) if they are set NoHuhLogs

=cut
sub requires_huh($$) {
	my ($self, $id) = @_;
	my ($result);

	# make a call to get_player_info()
	$result = $self->get_player_info($id);

	if (not defined $result) {
		# playerid not found
		return undef;
	}
	elsif (not defined $result->{'no_huh'}) {
		# player found, but no name (!!)
		return 0E0;
	}
	else {
		# player found, and has a name
		if ($result->{'no_huh'} eq 'HUH') {
			return 1;
		}
		elsif ($result->{'no_huh'} eq 'NOHUH') {
			return 0;
		}
		else {
			warn "unexpected no_huh value '$result->{'no_huh'}'";
			return undef;
		}
	}
}

=head2 aliases($self, $id)

This function returns an array-reference to a list of
aliases for the player

=cut
sub aliases($$) {
	my ($self, $id) = @_;
	my ($result);

	# make a call to get_player_info()
	$result = $self->get_player_info($id);

	if (not defined $result) {
		# playerid not found
		return undef;
	}
	elsif (not defined $result->{'aliases'}) {
		# player found, but no name (!!)
		return 0E0;
	}
	else {
		return $result->{'aliases'};
	}
}

=head1 COPYRIGHT

This module is Copyright (c) 2002 Chisel Wright.

=head1 LICENCE

This module is released under the terms of the
Artistic Licence.
(http://www.opensource.org/licenses/artistic-license.html)

=head1 AUTHOR

Chisel Wright <chisel@herlpacker.co.uk>, January 2002

=cut

1; # End of module
